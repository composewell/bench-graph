-- |
-- Module      : BenchGraph
-- Copyright   : (c) 2017 Composewell Technologies
--
-- License     : BSD3
-- Maintainer  : harendra.kumar@gmail.com
-- Stability   : experimental
-- Portability : GHC
--
-- BenchGraph generates a graph from benchmarking results (CSV) generated by
-- @guage@ or @criterion@, specifically, it generates comparative graphs for
-- several groups of benchmarks that can be compared.  The groups could
-- correspond to different packages providing similar and comparable operations
-- or even different versions of the same package. This is a convenient tool to
-- compare performance results of alternative libraries or versions of the same
-- package after you make a change that may impact the performance benchmarks
-- of the package.
--
-- The input is the CSV file generated by @gauge --csv=results.csv@ or a
-- similar output generated by @criterion@. You need to invoke the 'bgraph'
-- function with an appropriate 'Config' to control various parameters of graph
-- generation.
-- Benchmark results found in the CSV file can be classified into several
-- groups using a classifier function and each group is displayed side by side
-- in the graph on the same scale for comparison.  The constituent benchmarks
-- in each benchmark group are placed together as a group and a legend is
-- displayed to mark who is who.
--
-- See the test directory to for an example of how to use it.
-- A sample output can be found in the 'charts' directory.

{-# LANGUAGE TupleSections #-}
{-# LANGUAGE RecordWildCards #-}

module BenchGraph
    ( ComparisonStyle(..)
    , Config(..)
    , defaultConfig
    , bgraph
    ) where

import Control.Arrow (second)
import Control.Monad.Trans.State.Lazy (get, put)
import Data.List (nub, transpose)
import Data.Maybe (catMaybes, fromMaybe)
import System.Directory (createDirectoryIfMissing)
import Text.CSV (CSV, parseCSVFromFile)

import Graphics.Rendering.Chart.Easy
import Graphics.Rendering.Chart.Backend.Diagrams

-- | How to show the comparisons among benchmark groups.
data ComparisonStyle =
      CompareFull  -- ^ Show full results for all groups
    | CompareDelta -- ^ Show the first group with full results, show delta
                   -- from the first group for the subsequent groups.

data Config = Config
    {
    -- | The directory where the output graph should be placed. 'defaultConfig'
    -- uses the current directory as the default.
      outputDir   :: FilePath
    -- | The title to be embedded in the generated graph.
    , chartTitle  :: Maybe String
    -- | Given a benchmark name return a tuple (groupname, benchname), where
    -- groupname is the name of the group the benchmark should be placed in and
    -- benchname is the translated benchmark name to be displayed on the graph.
    -- If it returns Nothing the benchmark is ignored from the results.
    -- 'defaultConfig' uses a default classify function to place all benchmarks
    -- under one group named "default".
    , classifyBenchmark :: String -> Maybe (String, String)
    -- | The input to this function is the benchmarks to be plotted for each
    -- benchmark group. You can reorder them or filter them for presentation in
    -- the chart. Note that this works on the names generated by
    -- 'classifyBenchmark' and not the original benchmark names in the csv
    -- file.  'defaultConfig' supplies 'id' as the sort function.
    , sortBenchmarks :: [String] -> [String]
    -- | The input to this function contains groups in the order in which they
    -- appear in the benchmark data input.  You can use this to reorder and
    -- filter them for presentation in the chart. Note that this works on the
    -- names generated by 'classifyBenchmark'.  'defaultConfig' supplies 'id'
    -- as the sort function.
    , sortBenchGroups :: [String] -> [String]
    -- | (RangeMax, NumMajorTicks) of the plot on the y (time) axis in
    -- microseconds
    , setYScale :: Maybe (Double, Int)
    -- | How to show the comparisons
    , comparisonStyle :: ComparisonStyle
    }

defaultConfig :: Config
defaultConfig = Config
    { outputDir         = "."
    , chartTitle        = Nothing
    , classifyBenchmark = \b -> Just ("default", b)
    , sortBenchmarks    = id
    , sortBenchGroups   = id
    , setYScale         = Nothing
    , comparisonStyle   = CompareFull
    }

-- "values" is [(benchGroupName, [benchResult])]
-- benchResult contains results for each benchmark in "benchNames" in exactly
-- the same order.
genGroupGraph :: FilePath -> Config -> [String] -> [(String, [Maybe Double])] -> IO ()
genGroupGraph outputFile Config{..} benchNames values =
    -- XXX use filepath/path concatenation
    toFile
        def (outputDir
            ++ "/"
            ++ outputFile
            ++ ".svg") $ do
        case chartTitle of
            Just title -> do
                layout_title .= title
                layout_title_style . font_size .= 25
            Nothing -> return ()
        layout_x_axis . laxis_generate .= autoIndexAxis (map fst values)
        layout_x_axis . laxis_style . axis_label_style . font_size .= 16
        layout_y_axis . laxis_style . axis_label_style . font_size .= 14

        layout <- get
        case _layout_legend layout of
            Nothing -> return ()
            Just style@LegendStyle{..} -> do
                let s = style { _legend_plot_size = 22
                              -- , _legend_margin = 40
                              , _legend_position = LegendBelow
                              , _legend_label_style = _legend_label_style
                                    { _font_size = 14 }
                              }
                put $ layout { _layout_legend = Just s }

        -- layout_y_axis . laxis_override .= axisGridAtTicks
        let modifyLabels ad = ad {
                _axis_labels = map (map (second (++ " ms"))) (_axis_labels ad)
            }
        layout_y_axis . laxis_override .= modifyLabels

        case setYScale of
            Nothing -> return ()
            Just (rangeMax, nticks) ->
                layout_y_axis . laxis_override .= \_ ->
                    let indexes = take nticks [0,rangeMax/(fromIntegral nticks)..]
                    in makeAxis (map ((++ " ms") . show . floor)) (indexes, [], [])

        -- XXX We are mapping a missing value to 0, can we label it missing
        -- instead?
        let modifyVal x = map ((*1000) . fromMaybe 0) (snd x)
        plot $ fmap plotBars $ bars benchNames (addIndexes (map modifyVal values))

-- [[Double]] each list is multiple results for each benchmark
transposeLists :: [[a]] -> Maybe [[Maybe a]]
transposeLists xs =
    -- If each benchmark does not have the same number of results then reject
    -- all because the results may not correspond with each other when zipped.
    case nub $ map length xs of
        [0] -> Nothing
        [n] ->
            let ys = map (convertToMaybe n) xs
            in Just $ transpose ys
        [0,n] ->
            -- some packages may have missing benchmarks
            -- fill the empty results with Nothing
            let ys = map (convertToMaybe n) xs
            in Just $ transpose ys
        _ -> Nothing
    where
        convertToMaybe n zs = case zs of
            [] -> replicate n Nothing
            x  -> map Just x

-- We return a list of lists as the same benchmark may appear more than once if
-- we ran benchmarks for the same package multiple times. This is helpful in
-- comparing the benchmarks for the same package after fixing something.
getResultsForBenchGroup
    :: CSV
    -> (String -> Maybe (String, String))
    -> String
    -> [String]
    -> Maybe [[Maybe Double]]
getResultsForBenchGroup csvData classify groupName bmnames  =
    -- XXX this can be quite inefficient, need to do it better
    transposeLists $ map getBenchmarkMeans bmnames

    where

    match name origName =
        case classify origName of
            Nothing -> False
            Just (g, n) -> g == groupName && n == name

    getBenchmarkMeans :: String -> [Double]
    getBenchmarkMeans bmname =
        -- field at index 1 is the mean
        map read $ map (!! 1) $ filter (match bmname .  head) csvData

genGraph :: FilePath -> Config -> CSV -> IO ()
genGraph outfile cfg@Config{..} csvData =
    -- bmResults contains benchmark results for bmnames for each group
    genGroupGraph outfile cfg bmnames bmResults

    where

    getBenchNames = nub $ map head csvData
    bmTuples = catMaybes $ map classifyBenchmark getBenchNames
    -- XXX assert that for each group we get the same bmnames
    bmnames = sortBenchmarks $ nub $ map snd bmTuples
    bmgroups = sortBenchGroups $ nub $ map fst bmTuples

    grpGetResults groupName =
        let res = getResultsForBenchGroup csvData classifyBenchmark
                                          groupName bmnames
        in case res of
            Nothing -> Nothing
            Just xs ->
                case length xs of
                    0 -> Nothing
                    1 -> Just $ map (groupName,) xs
                    _ -> Just $ zipWith (withIndexes groupName) [(1::Int)..] xs
    withIndexes groupName indx y = (groupName ++ "(" ++ show indx ++ ")", y)

    -- this produces results for all groups
    -- [(groupName, [Maybe Double])]
    bmResults = concat $ catMaybes $ map grpGetResults bmgroups

-- XXX display GHC version as well
-- XXX display the OS/arch
-- This data should be in the measurement data
--
-- TODO Specify which field in the CSV file you want to plot.
-- default is time, the first field
-- Specify the units of the field

-- | The first parameter is an input file containing CSV data as generated by
-- @gauge --csv=results.csv@ or a similar output generated by @criterion@.  The
-- second parameter is the name of the output file containing the graph SVG
-- image. The third parameter is the configuration to customize the graph, you
-- can start with 'defaultConfig' as the base and set any of the fields that
-- you may want to change.
bgraph :: FilePath -> FilePath -> Config -> IO ()
bgraph inputFile outputFile cfg@Config{..} = do
    createDirectoryIfMissing True outputDir

    csvData <- parseCSVFromFile inputFile
    case csvData of
        Left e -> error $ show e
        Right dat -> genGraph outputFile cfg dat
