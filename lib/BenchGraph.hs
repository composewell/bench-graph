-- |
-- Module      : BenchGraph
-- Copyright   : (c) 2017 Composewell Technologies
--
-- License     : BSD3
-- Maintainer  : harendra.kumar@gmail.com
-- Stability   : experimental
-- Portability : GHC
--
-- BenchGraph generates a graph from benchmarking results (CSV) generated by
-- @guage@ or @criterion@, specifically, it generates comparative graphs for
-- several groups of benchmarks that can be compared.  The groups could
-- correspond to different packages providing similar and comparable operations
-- or even different versions of the same package. This is a convenient tool to
-- compare performance results of alternative libraries or versions of the same
-- package after you make a change that may impact the performance benchmarks
-- of the package.
--
-- The input is the CSV file generated by @gauge --csv=results.csv@ or a
-- similar output generated by @criterion@. You need to invoke the 'bgraph'
-- function with an appropriate 'Config' to control various parameters of graph
-- generation.
-- Benchmark results found in the CSV file can be classified into several
-- groups using a classifier function and each group is displayed side by side
-- in the graph on the same scale for comparison.  The constituent benchmarks
-- in each benchmark group are placed together as a group and a legend is
-- displayed to mark who is who.
--
-- See the test directory to for an example of how to use it.
-- A sample output can be found in the 'charts' directory.

{-# LANGUAGE TupleSections #-}
{-# LANGUAGE RecordWildCards #-}

module BenchGraph
    ( ComparisonStyle(..)
    , Config(..)
    , defaultConfig
    , bgraph
    ) where

import Control.Arrow (second)
import Control.Monad (when)
import Control.Monad.Trans.State.Lazy (get, put)
import Data.List (nub, transpose, findIndex, groupBy)
import Data.Maybe (catMaybes, fromMaybe)
import System.Directory (createDirectoryIfMissing)
import Text.CSV (CSV, parseCSVFromFile)

import Graphics.Rendering.Chart.Easy
import Graphics.Rendering.Chart.Backend.Diagrams

-- | How to show the comparisons among benchmark groups.
data ComparisonStyle =
      CompareFull  -- ^ Show full results for all groups
    | CompareDelta -- ^ Show the first group with full results, show delta
                   -- from the first group for the subsequent groups.
    deriving Eq

data Config = Config
    {
    -- | The directory where the output graph should be placed. 'defaultConfig'
    -- uses the current directory as the default.
      outputDir   :: FilePath
    -- | The title to be embedded in the generated graph.
    , chartTitle  :: Maybe String
    -- | Given a benchmark name return a tuple (groupname, benchname), where
    -- groupname is the name of the group the benchmark should be placed in and
    -- benchname is the translated benchmark name to be displayed on the graph.
    -- If it returns Nothing the benchmark is ignored from the results.
    -- 'defaultConfig' uses a default classify function to place all benchmarks
    -- under one group named "default".
    , classifyBenchmark :: String -> Maybe (String, String)
    -- XXX need ability to sort in ascending order of bar heights for a
    -- particular group. For that we will need access to the full data.
    -- | The input to this function is the benchmarks to be plotted for each
    -- benchmark group. You can reorder them or filter them for presentation in
    -- the chart. Note that this works on the names generated by
    -- 'classifyBenchmark' and not the original benchmark names in the csv
    -- file.  'defaultConfig' supplies 'id' as the sort function.
    , sortBenchmarks :: [String] -> [String]
    -- | The input to this function contains groups in the order in which they
    -- appear in the benchmark data input.  You can use this to reorder and
    -- filter them for presentation in the chart. Note that this works on the
    -- names generated by 'classifyBenchmark'.  'defaultConfig' supplies 'id'
    -- as the sort function.
    , sortBenchGroups :: [String] -> [String]
    -- XXX ability to sepcify different units e.g. Milliseconds etc.
    -- | (RangeMin, RangeMax, NumIntervals) of the plot on the y (time) axis in
    -- microseconds
    , setYScale :: Maybe (Double, Double, Int)
    -- | How to show the comparisons
    , comparisonStyle :: ComparisonStyle
    }

defaultConfig :: Config
defaultConfig = Config
    { outputDir         = "."
    , chartTitle        = Nothing
    , classifyBenchmark = \b -> Just ("default", b)
    , sortBenchmarks    = id
    , sortBenchGroups   = id
    , setYScale         = Nothing
    , comparisonStyle   = CompareFull
    }

-- "values" is [(benchGroupName, [benchResult])]
-- benchResult contains results for each benchmark in "benchNames" in exactly
-- the same order.
genGroupGraph :: FilePath -> Config -> [String] -> [(String, [Maybe Double])] -> IO ()
genGroupGraph outputFile Config{..} benchNames values = do
    -- XXX use filepath/path concatenation
    toFile
        def (outputDir
            ++ "/"
            ++ outputFile
            ++ ".svg") $ do
        case chartTitle of
            Just title -> do
                layout_title .= title
                layout_title_style . font_size .= 25
            Nothing -> return ()

        -- woraround for a bug that renders the plot badly when using a single
        -- cluster in the bar chart.
        let vals =
                if length values == 1
                then values ++ [([], [])]
                else if comparisonStyle == CompareDelta
                     then let (_, h) = head values
                              toDelta x1 x2 =
                                case x1 of
                                    Nothing -> Nothing
                                    Just v -> fmap (\v1 -> v - v1) x2
                              convert (name, xs) = ("(-)" ++ name, zipWith toDelta h xs)
                          in head values : map convert (tail values)
                     else values

        layout_x_axis . laxis_generate .= autoIndexAxis (map fst vals)
        layout_x_axis . laxis_style . axis_label_style . font_size .= 16
        layout_y_axis . laxis_style . axis_label_style . font_size .= 14

        layout <- get
        case _layout_legend layout of
            Nothing -> return ()
            Just style@LegendStyle{..} -> do
                let s = style { _legend_plot_size = 22
                              -- , _legend_margin = 40
                              , _legend_position = LegendBelow
                              , _legend_label_style = _legend_label_style
                                    { _font_size = 14 }
                              }
                put $ layout { _layout_legend = Just s }

        -- XXX automatically use ns/us/ms/sec on the scale
        -- layout_y_axis . laxis_override .= axisGridAtTicks
        let modifyLabels ad = ad {
                _axis_labels = map (map (second (++ " ms"))) (_axis_labels ad)
            }
        layout_y_axis . laxis_override .= modifyLabels

        -- XXX remove the unit and /1000 hardcoding here
        case setYScale of
            Nothing -> return ()
            Just (rangeMin, rangeMax, nInterval) ->
                layout_y_axis . laxis_override .= \_ ->
                    let r = (rangeMax - rangeMin)/(1000 * fromIntegral nInterval)
                        rmin = rangeMin/1000
                        indexes = take (nInterval + 1) [rmin, rmin + r..]
                    in makeAxis (map ((++ " ms") . show . floor)) (indexes, [], [])

        -- XXX We are mapping a missing value to 0, can we label it missing
        -- instead?
        let modifyVal x = map ((*1000) . fromMaybe 0) (snd x)
        plot $ fmap plotBars $ bars benchNames (addIndexes (map modifyVal vals))

-- [[Double]] each list is multiple results for each benchmark
transposeLists :: [[a]] -> Maybe [[Maybe a]]
transposeLists xs =
    -- If each benchmark does not have the same number of results then reject
    -- all because the results may not correspond with each other when zipped.
    case nub $ map length xs of
        [0] -> Nothing
        [n] ->
            let ys = map (convertToMaybe n) xs
            in Just $ transpose ys
        [0,n] ->
            -- some packages may have missing benchmarks
            -- fill the empty results with Nothing
            let ys = map (convertToMaybe n) xs
            in Just $ transpose ys
        _ -> Nothing
    where
        convertToMaybe n zs = case zs of
            [] -> replicate n Nothing
            x  -> map Just x

-- We return a list of lists as the same benchmark may appear more than once if
-- we ran benchmarks for the same package multiple times. This is helpful in
-- comparing the benchmarks for the same package after fixing something.
getResultsForBenchGroup
    :: CSV
    -> (String -> Maybe (String, String))
    -> String
    -> [String]
    -> Maybe [[Maybe Double]]
getResultsForBenchGroup csvData classify groupName bmnames  =
    -- XXX this can be quite inefficient, need to do it better
    transposeLists $ map getBenchmarkMeans bmnames

    where

    match name origName =
        case classify origName of
            Nothing -> False
            Just (g, n) -> g == groupName && n == name

    getBenchmarkMeans :: String -> [Double]
    getBenchmarkMeans bmname =
        -- field at index 1 is the mean
        map read $ map (!! 1) $ filter (match bmname .  head) csvData

genGraph :: FilePath -> Config -> CSV -> IO ()
genGraph outfile cfg@Config{..} csvData = do
    when (bmgroups == []) $ error
        "No benchmark groups to plot. Please check your benchmark \
        \classifier (classifyBenchmarks), group filter (sortBenchGroups) or \
        \the input data"

    when (bmnames == []) $ error
        "No benchmark names to plot. Please check your benchmark \
        \classifier (classifyBenchmarks), filter (sortBenchmarks) or \
        \the input data"

    -- bmResults contains benchmark results for bmnames for each group
    genGroupGraph outfile cfg bmnames bmResults

    where

    getBenchNames = nub $ map head csvData
    bmTuples = catMaybes $ map classifyBenchmark getBenchNames
    -- XXX assert that for each group we get the same bmnames
    bmnames = sortBenchmarks $ nub $ map snd bmTuples
    bmgroups = sortBenchGroups $ nub $ map fst bmTuples

    grpGetResults groupName =
        let res = getResultsForBenchGroup csvData classifyBenchmark
                                          groupName bmnames
        in case res of
            Nothing -> Nothing
            Just xs ->
                case length xs of
                    0 -> Nothing
                    1 -> Just $ map (groupName,) xs
                    _ -> Just $ zipWith (withIndexes groupName) [(1::Int)..] xs
    withIndexes groupName indx y = (groupName ++ "(" ++ show indx ++ ")", y)

    -- this produces results for all groups
    -- [(groupName, [Maybe Double])]
    bmResults = concat $ catMaybes $ map grpGetResults bmgroups

-- XXX display GHC version as well
-- XXX display the OS/arch
-- This data should be in the measurement data
--
-- TODO Specify the units of the field being plotted, this should be mentioned
-- in the CSV header.

-- gauge generates two different formats of csv files, one using --csv option
-- and the other using --csvraw option. We support both with auto-detection
-- based on the header line
-- XXX use a function isHeaderLine to detect header line
-- We need to use the same for filtering out header lines
getFieldIndex :: String -> [String] -> Maybe Int
getFieldIndex fieldName fields =
    case fields of
        "iters" : _ ->
            -- the header generated by gauge is incorrect the first field
            -- should be benchmark name and not iters
            fmap (+ 1) $ findIndex (== fieldName) fields
        _ -> Nothing

filterIndexes :: [Int] -> [String] -> [String]
filterIndexes ixs fields =
    let indxed = zip [0..] fields
        res = filter (\(x,_) -> x `elem` ixs) indxed
    in if length res /= length ixs
       then error $ "Cannot find required indexes " ++ show ixs
                    ++ " in csv row " ++ show fields
       else snd $ unzip res

-- XXX we can specify the name of the field that identifies the benchmark
-- name, units of the field being plotted. And also if there is an "iters"
-- field specify the name of that as well.

-- | The first parameter is an input file containing CSV data as generated by
-- @gauge --csv=results.csv@ or a similar output generated by @criterion@.  The
-- second parameter is the name of the output file containing the graph SVG
-- image. The third parameter is the configuration to customize the graph, you
-- can start with 'defaultConfig' as the base and set any of the fields that
-- you may want to change.
bgraph :: FilePath -> FilePath -> String -> Config -> IO ()
bgraph inputFile outputFile fieldName cfg@Config{..} = do
    createDirectoryIfMissing True outputDir

    csvData <- parseCSVFromFile inputFile
    case csvData of
        Left e -> error $ show e
        Right d -> do
            -- get the index of the field and remove all other fields
            -- collapse multiple iterations into mean values
            let dat = filter (/= [""]) d -- cleanup blank rows
                idxs = nub $ catMaybes $ map (getFieldIndex fieldName) dat
                idx = case idxs of
                    [] -> error $ "Field [" ++ fieldName
                                  ++ "] cannot be found in the CSV input"
                    [x] -> x
                    _ -> error $ "Found multiple indexes " ++ show idxs
                                 ++ " for field [" ++ fieldName
                                 ++ "] in the CSV input"

                -- Just keep the required fields, remove others
                -- XXX we assume that index 0 is the benchmark name and index 1
                -- is the number of iterations
                dat1 :: [[String]]
                dat1 = map (filterIndexes [0, 1, idx]) $
                    -- Remove header rows
                    filter (\xs -> xs !! (idx - 1) /= fieldName) dat

                -- group successive iterations
                dat2 :: [[[String]]]
                dat2 = groupBy (\(x1:_) (x2:_) -> x1 == x2) dat1

                -- reduce successive iterations to a single row with the mean
                foldToMean xs =
                    let iters  = map (read . (!! 0)) xs :: [Double]
                        values = map (read . (!! 1)) xs :: [Double]
                    in show (sum values / sum iters)

                dat3 = map (\xs -> [head $ map head xs, foldToMean $ map tail xs]) dat2
            -- XXX send tuples [(String, Double)] instead of [[String]]
            -- XXX determine the units based on the field name
            -- We can pass here the units to be displayed by the chart
            genGraph outputFile cfg dat3
